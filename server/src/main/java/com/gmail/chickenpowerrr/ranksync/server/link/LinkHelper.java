package com.gmail.chickenpowerrr.ranksync.server.link;

import com.gmail.chickenpowerrr.ranksync.api.bot.BasicLinkInfo;
import com.gmail.chickenpowerrr.ranksync.api.player.LinkInfo;
import com.gmail.chickenpowerrr.ranksync.api.player.Player;
import com.gmail.chickenpowerrr.ranksync.server.plugin.RankSyncServerPlugin;
import com.gmail.chickenpowerrr.ranksync.api.user.User;
import com.gmail.chickenpowerrr.ranksync.server.language.Translation;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * This class manages the basic logic to create a complete middleware chain
 *
 * @author Chickenpowerrr
 * @since 1.0.0
 */
public class LinkHelper {

  private final RankSyncServerPlugin rankSyncPlugin;
  private final AbstractMiddleware linkMiddleware;
  private final AbstractMiddleware unlinkMiddleware;
  private final Map<String, Map.Entry<Long, Player>> authenticationKeys = new HashMap<>();
  private final Map<LinkInfo, Map<UUID, Player>> linkInfos = new HashMap<LinkInfo, Map<UUID, Player>>() {{
    put(new BasicLinkInfo("Discord", Translation.DISCORD_LINKINFO.getTranslation()),
        new HashMap<>());
  }};

  /**
   * Sets the link and the unlink middleware up
   */
  public LinkHelper(RankSyncServerPlugin rankSyncPlugin) {
    this.rankSyncPlugin = rankSyncPlugin;
    this.linkMiddleware = new RequestLimitCheckMiddleware(this.rankSyncPlugin, this);
    this.linkMiddleware.setNext(new ValidServiceCheckMiddleware(this))
        .setNext(new ValidIdCheckMiddleware(this));
    this.unlinkMiddleware = new RequestLimitCheckMiddleware(this.rankSyncPlugin, this);
    this.unlinkMiddleware.setNext(new ValidServiceCheckMiddleware(this));

    startAuthCleanup();
  }

  /**
   * Adds a authentication key that will expire after five minutes
   *
   * @param player the Discord user that will try to authenticate
   * @param key the key that can be used to link the account
   */
  public void addAuthenticationKey(Player player, String key) {
    this.authenticationKeys.put(key, new HashMap.SimpleEntry<>(System.currentTimeMillis(), player));
  }

  /**
   * Returns if the complete link middleware chain is true
   *
   * @param user the player that invokes the middleware
   * @param uuid the UUID of the player that invokes the middleware
   * @param service the service the middleware has been invoked from
   * @param key the key used to link the player
   * @return if the complete link middleware chain is true
   */
  public boolean isAllowedToLink(User user, UUID uuid, String service,
      String key) {
    return this.linkMiddleware.allowed(user, uuid, service, key);
  }

  /**
   * Returns if the complete unlink middleware chain is true
   *
   * @param user the player that invokes the middleware
   * @param uuid the UUID of the player that invokes the middleware
   * @param service the service the middleware has been invoked from
   * @return if the complete unlink middleware chain is true
   */
  public boolean isAllowedToUnlink(User user, UUID uuid, String service) {
    return this.unlinkMiddleware.allowed(user, uuid, service, null);
  }

  /**
   * Returns if the given key is valid
   *
   * @param string the possible key generated by Discord
   * @return if the given key is valid
   */
  boolean isValidAuthenticationKey(String string) {
    return this.authenticationKeys.containsKey(string);
  }

  /**
   * Starts the cleanup that deletes a key after five minutes
   */
  private void startAuthCleanup() {
    this.rankSyncPlugin.runTaskTimer(() -> this.authenticationKeys.entrySet().stream()
        .filter(entry -> entry.getValue().getKey() + 1000 * 60 * 5 < System.currentTimeMillis())
        .map(Map.Entry::getKey).collect(Collectors.toSet())
        .forEach(this.authenticationKeys::remove), 20 * 30, 20 * 30);
  }

  /**
   * Returns all possible links
   */
  public Collection<LinkInfo> getLinkInfos() {
    return Collections.unmodifiableCollection(this.linkInfos.keySet());
  }

  /**
   * Returns the link info with the given name
   *
   * @param name the of the service
   * @return the link info with the given name
   */
  public LinkInfo getLinkInfo(String name) {
    return this.linkInfos.keySet().stream()
        .filter(linkInfo -> linkInfo.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
  }

  /**
   * Links an account to another service
   *
   * @param uuid the Minecraft UUID
   * @param service the service that should get linked
   * @param key the key used to link the account
   */
  public CompletableFuture<Void> link(UUID uuid, String service, String key) {
    Map.Entry<Long, Player> authInfo = this.authenticationKeys.get(key);

    return this.rankSyncPlugin.getBot(service).getEffectiveDatabase()
        .setUuid(authInfo.getValue().getPersonalId(), uuid).thenAccept(aVoid -> {
          this.linkInfos.get(getLinkInfo(service)).put(uuid, authInfo.getValue());
          this.authenticationKeys.remove(key);
        });
  }

  /**
   * Updates the synced ranks over the services
   *
   * @param uuid the UUID that represents the Player
   */
  public void updateRanks(UUID uuid) {
    if (this.rankSyncPlugin.getBot("discord").isEnabled()) {
      this.rankSyncPlugin.getBot("discord").getPlayerFactory().getPlayer(uuid)
          .thenAccept(player -> {
            if (player != null) {
              player.update();
            }
          });
    }
  }
}
